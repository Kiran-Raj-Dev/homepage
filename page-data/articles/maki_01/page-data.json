{
    "componentChunkName": "component---src-templates-article-tsx",
    "path": "/articles/maki_01",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"type\": \"article\",\n  \"title\": \"Maki, Atoms and Time Travel\",\n  \"description\": \"How to implement an efficient time traveling renderer.\",\n  \"banner\": \"/social_banner/maki_01.png\",\n  \"slug\": \"maki_01\",\n  \"date\": \"2022-01-26T00:00:00.000Z\",\n  \"listed\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(AutoPlayVideo, {\n    src: full_showcase_01,\n    mdxType: \"AutoPlayVideo\"\n  }), mdx(\"p\", null, \"To create animations for technical concepts, one is advised to use graphics software with a programmatic approach.\\nWhile these provide the required precision, they suffer from an inherent disconnect between input and output.\\nAn alternative are WYSIWYG programs, which avoid this detachment with interactivity at the cost of precision.\"), mdx(\"p\", null, \"The purpose of this article is to outline how a program for interactive and programmatic animation development can be implemented.\\nTo experiment with different technologies and programming paradigms, I created a developmental implementation called Maki.\\nThis article analyses Maki's design and evaluates the feasibility of its inclusion in an already existing animation framework.\"), mdx(\"h1\", null, \"Maki\"), mdx(\"p\", null, \"The goal of Maki is to allow the user to create 3D animations using Python.\\nWhile the user is constructing their animation in an interactive shell, Maki shows the current status of the animation in a separate window.\\nThe user is able to freely move the camera in that window.\\nIn addition to that, Maki provides the ability to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"jump in time\"), \";\\nThe use can decide which frame of the animation should be played.\"), mdx(\"h1\", null, \"Atoms\"), mdx(\"p\", null, \"Just like how real atoms were thought to be the indivisible unit of the universe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s are the smallest renderable unit in Maki.\\nA collection of them form a frame, multiple of which form an entire scene that can be rendered to a video file.\\nThe first frame is frame \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \".\\nIt cannot display anything as it is used as the foundation for any following frames.\\nAny subsequent frames can be the target of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s.\\nThese \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s alter an atom: for example move the atom, apply a linear transformation, change the color or just change the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" flag.\\nThis flag, set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", excludes the atom from the being-rendered-club, which explains why the frame \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \" never shows anything.\"), mdx(\"h2\", null, \"On the Matter of Frames\"), mdx(\"p\", null, \"There are two different types of frames when talking about Maki:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Frames building a scene can be stored in an output video file.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The frame rate of the interactive Maki window is detached from that idea.\\nIf the user wishes to \\\"freeze\\\" time and show one frame for as long as they like, they can do that while still being able to fly around in the scene.\\nIn fact the user can freely choose in which direction the scene's time should flow.\\nThis is analogous to any video editing software.\\nThere the frames of the video being editing also don't have anything to do with the frame rate of the editor's window.\")), mdx(\"h2\", null, \"Atom-Classes Overview\"), mdx(\"p\", null, \"To implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s a multitude of different classes is used.\\nThis chapter briefly summarizes their reason to life.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"Atom\")), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" stores all the data required to render that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nThis mainly includes any vertex data, like position or colour.\"), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"struct Atom {\\n    bool render {false};\\n\\n    // to be defined by implementation:\\n    // static constexpr const char* type_name {\\\"AtomType\\\"};\\n};\\n\\nstruct QuadrilateralAtom: public Atom {\\n    std::array<vec3, 4> ver_pos {\\n        vec3 {-1.0f, -1.0f, +0.0f},  // bottom left\\n        vec3 {+1.0f, -1.0f, +0.0f},  // bottom right\\n        vec3 {-1.0f, +1.0f, +0.0f},  // top    left\\n        vec3 {+1.0f, +1.0f, +0.0f}}; // top    right\\n\\n    ...\\n\\n    static constexpr const char* type_name {\\\"Quadrilateral\\\"};\\n};\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomDiff\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s are immutable (always declared \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \").\\nThey define how an atom has to be altered to cross a frame-border (from one frame to the next, or back from the next to the current).\\nThis functionality is implemented in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions.\\nThese take an atom and apply (or reverse) the changes this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" represents.\\nTheir \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m_id\"), \" member variable can be used to determine the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" should be used for.\"), mdx(\"p\", null, \"Templating is used to accept any type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template<typename AtomType>\\nclass ToggleRenderDiff: public AtomDiff<AtomType> {\\npublic:\\n    explicit ToggleRenderDiff(uint32_t id)\\n        : AtomDiff<AtomType> {id} {}\\n\\n    virtual void apply(AtomType& atom) const override\\n    {\\n        atom.render = !atom.render;\\n    }\\n    virtual void reverse(AtomType& atom) const override\\n    {\\n        atom.render = !atom.render;\\n    }\\n};\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomDiffFrame\")), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffFrame\"), \" is a container for all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s belonging to a single frame.\\nTemplating is again used to specify the type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" being used.\\nIn this case the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions take an entire list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s as a parameter.\\nThe aforementioned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m_id\"), \" member variable is used to apply (or reverse) the correct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" on the correct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void apply(std::vector<AtomType>& atoms) const\\n{\\n    for(const AtomDiff<AtomType>* atom_diff: m_atom_diffs) {\\n        atom_diff->apply(atoms[atom_diff->get_id()]);\\n    }\\n}\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomDiffLifetime\")), mdx(\"p\", null, \"Multiple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffFrame\"), \"s are stored in one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \", one for each frame.\\nThus an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \" represents the entire scene for one type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \", as it is again templated.\\nTheir \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions take an added \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frame\"), \" and simply call the underlying functions defined in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffFrame\"), \" for the specified frame.\"), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomChain\")), mdx(\"p\", null, \"Being one of the central classes, an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomChain\"), \" contains all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atoms\"), \" of one type in a specific state defined by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nIt can be seen as a pointing to within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nThis \\\"pointer\\\" can freely be moved around to represent the requested frame.\"), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_frame\"), \" member function takes a target frame and an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \"'s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions are then used to adjust all atoms to match the target frame.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void set_frame(\\n    uint32_t frame,\\n    const AtomDiffLifetime<AtomType>& atom_diff_lifetime)\\n{\\n    ...\\n\\n    while(m_frame < frame)\\n        // adjust m_frame and call atom_diff_lifetime.apply\\n        next_frame(atom_diff_lifetime);\\n    while(m_frame > frame)\\n        prev_frame(atom_diff_lifetime);\\n}\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomDispenser\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \" gives birth to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atoms\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffs\"), \" besides owning one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \" and all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomChains\"), \" for each type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nMultiple templated member functions are being used to access the correct ones.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"class AtomDispenser {\\n\\n    ...\\n\\n    template<typename AtomType>\\n    AtomDiffLifetime<AtomType>& get_diff_lifetime();\\n    \\n    ...\\n};\\n\\n// for CuboidAtoms\\ntemplate<>\\ninline AtomDiffLifetime<CuboidAtom>& AtomDispenser::get_diff_lifetime<CuboidAtom>()\\n{\\n    return m_cuboid_diff_lifetime;\\n}\\n// for QuadrilateralAtoms\\ntemplate<>\\ninline AtomDiffLifetime<QuadrilateralAtom>& AtomDispenser::get_diff_lifetime<QuadrilateralAtom>()\\n{\\n    return m_quadrilateral_diff_lifetime;\\n}\\n\")), mdx(\"h2\", null, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomRenderer\")), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomRenderer\"), \" uses the underlying rendering abstraction to actually render an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nThe implementation of such may vary wildly as each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" has a different optimal way of being rendered.\\nWhile some may use a common base class (like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BatchRenderer\"), \") others stand on their own.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomRendererRouter\"), \" is unfortunately needed to make these different implementations accessible from the templated world of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template<typename AtomType>\\nstruct AtomRendererRouter {\\n    // can't be used unspecialized\\n    typedef void type;\\n};\\n\\ntemplate<>\\nstruct AtomRendererRouter<CuboidAtom> {\\n    typedef CuboidRenderer type;\\n};\\n\\ntemplate<>\\nstruct AtomRendererRouter<QuadrilateralAtom> {\\n    typedef QuadrilateralRenderer type;\\n};\\n\")), mdx(\"p\", null, \"This router can be used like this to resolve \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" types to their respective renderer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"typename AtomRendererRouter<CuboidAtom>::type* m_cuboid_renderer {nullptr};\\n\")), mdx(\"p\", null, \"Being converted to this by the compiler:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"CuboidRenderer* m_cuboid_renderer {nullptr};\\n\")), mdx(\"p\", null, \"(The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{nullptr}\"), \" is not necessary but always a nice touch ^^).\"), mdx(\"h2\", null, \"Why Templates?\"), mdx(\"p\", null, \"Why not use the arguably much simpler object-oriented approach?\"), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" can be applied to any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" that provides the used member functions and/or effected data (an atom that doesn't have a color can't be painted red).\\nSo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s are templated to suit any such \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nInstead of using templates, I could have used an abstract \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" base class and make the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s be applied to an inheritor of such base class.\"), mdx(\"p\", null, \"The problem with that lays in the way the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s are being accessed.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s are currently stored in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \", which is the screwed up C++ way of saying \\\"dynamic size array\\\".\\nThere is one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" for each type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nMemory allocated by an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" is always contiguous.\\nTherefore the atoms lay side by side and the renderer, chewing through all atoms one at a time, gets sped up by the hardware prefetcher.\"), mdx(\"p\", null, \"But this only works since the compiler knows the size of that type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nIf I were to use inheritance, the size of an actual \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" isn't always the same.\\nFor example a Cube needs a lot more data than a triangle and thus requires more data.\\nSo the way to store multiple different inherited types of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" is by storing pointers to the actual objects.\\nThat means that the objects are scattered all over the memory and the hardware prefetcher feels an urge to give up.\\nIn this case using contiguous memory amounts to a total performance increase of 35 to 60 (!!!) percent.\"), mdx(\"h2\", null, \"Repo Overview\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \".\\n\\u251C\\u2500\\u2500 maki\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 maki.cpp\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u251C\\u2500\\u2500 maki_core\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 include\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 maki.h\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 res\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 shaders\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 cuboid_frag.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 cuboid_vert.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 simple_fragment.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u2514\\u2500\\u2500 simple_vertex.glsl\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atoms\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_atom.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 quadrilateral_atom.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 quadrilateral_atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderers\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 batch_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 batch_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 quadrilateral_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 quadrilateral_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_chain.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff_frame.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff_lifetime.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_dispenser.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_dispenser.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 atom_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 core\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 definitions.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 log.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 log.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 thread_safety.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 thread_safety.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 driver\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera_driver.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera_driver.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 interface.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 render_driver_control.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 render_driver.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 render_driver_render.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 platform\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 glfw\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 glfw_window.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 enums.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 event.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 window.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 window.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_shader.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_shader.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_stringifier.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_stringifier.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_types.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_vertex_array.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 opengl_vertex_array.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 buffer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 buffer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 shader.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 shader.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 types.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 vertex_array.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 vertex_array.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 pch.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 pch.h\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u251C\\u2500\\u2500 stub\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 main.cpp\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u2514\\u2500\\u2500 CMakeLists.txt\\n\")), mdx(\"p\", null, \"Created with\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"tree --dirsfirst . -I 'vendor|build|pretty_bugs|block.txt|imgui.ini|LICENSE|maki.cpython-310-x86_64-linux-gnu.so|maki_showcase.ipynb|README.md'\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"January 2022","title":"Maki, Atoms and Time Travel","description":"How to implement an efficient time traveling renderer.","banner":"/social_banner/maki_01.png"}}},"pageContext":{"slug":"maki_01"}},
    "staticQueryHashes": ["1751226025"]}