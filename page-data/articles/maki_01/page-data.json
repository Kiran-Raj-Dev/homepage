{
    "componentChunkName": "component---src-templates-article-tsx",
    "path": "/articles/maki_01",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"type\": \"article\",\n  \"title\": \"Maki, Atoms and Time Travel\",\n  \"description\": \" Maki showcases how a program for interactive and programmatic animation development can be implemented.\\nTo create animations for technical concepts, one is advised to use graphics software with a programmatic approach. While these provide the required precision, they suffer from an inherent disconnect between input and output. An alternative are WYSIWYG programs, which avoid this detachment with interactivity at the cost of precision.\\nMaki combines the best of both worlds. \",\n  \"banner\": \"/social_banner/maki_01.png\",\n  \"thumb\": \"../../../static/social_banner/maki_01.png\",\n  \"slug\": \"maki_01\",\n  \"date\": \"2022-01-26T00:00:00.000Z\",\n  \"listed\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(AutoPlayVideo, {\n    src: full_showcase_01,\n    poster: full_showcase_01_poster,\n    mdxType: \"AutoPlayVideo\"\n  }), mdx(\"p\", null, \"To create animations for technical concepts, one is advised to use graphics software with a programmatic approach.\\nWhile these provide the required precision, they suffer from an inherent disconnect between input and output.\\nAn alternative are WYSIWYG programs, which avoid this detachment with interactivity at the cost of precision.\"), mdx(\"p\", null, \"The purpose of this article is to outline how a program for interactive and programmatic animation development can be implemented.\\nTo experiment with different technologies and programming paradigms, I created a developmental implementation called Maki.\\nThis article analyses Maki's design and evaluates the feasibility of its inclusion in an already existing animation framework.\"), mdx(\"h1\", {\n    \"id\": \"maki\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Maki\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#maki\",\n    \"aria-label\": \"maki permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Extensibility\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"performance\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ease of use\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"strict type and thread safety\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"clear ownership\"), \" and the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"fear of loosing type information\"), \" form Maki's main ideals.\\nI chose C++ because it enforces \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"strict rules\"), \" and offers handy containers, algorithms and many light-weight abstractions, aiding in the development of a complex system, without compromising on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"performance\"), \".\"), mdx(\"p\", null, \"The goal of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/christopher-besch/maki\"\n  }, \"Maki\"), \" is to allow the user to create 3D animations using Python;\\nwhile the user is constructing their animation in an interactive shell, Maki shows the current status of the enimation in a separate window.\\nThe user is able to freely move the camera in that window.\\nIn addition to that, Maki provides the ability to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"jump in time\"), \";\\nThe user can decide which frame of the animation should be played.\"), mdx(\"p\", null, \"This allows an \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"easy to use\"), \" workflow minimizing the time between defining animations and seeing and playing with the results.\"), mdx(\"h1\", {\n    \"id\": \"clear-ownership\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Clear Ownership\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#clear-ownership\",\n    \"aria-label\": \"clear ownership permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Shared ownership, where multiple classes or functions own a single resource, facilitates programs where \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"everything owns everything\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"everything calls everything\"), \".\\nThis is relatively easy to implement (The programmer doesn't have to consider complicated ownership models.) but easily leads to stack traces resembling hell on earth.\\nWhen instead every resource is owned by only one object, that object's constructor acquires any needed resources and the destructor subsequently frees them.\\nThis programming technique (called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.cppreference.com/w/cpp/language/raii\"\n  }, \"RAII\"), \" by the C++ committee for silly names) leaves no need for any garbage collection.\\nTherefore \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"clear ownership\"), \" is highly performant and safe.\"), mdx(\"p\", null, \"Though in some situations the same resource has to be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"used\"), \" by multiple objects.\\nWith an emphasis on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"used\"), \";\\nthese situations don't warrant the use of shared ownership.\\nInstead the resource can be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"borrowed\"), \".\\nFor example, without going into detail of what these classes actually do:\\nA \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RenderDriver\"), \" owns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Renderer\"), \" and an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \".\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \" needs the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Renderer\"), \" to perform its task, so it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"borrows\"), \" it from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RenderDriver\"), \".\\nAnd because both the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Renderer\"), \" are owned by the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RenderDriver\"), \"; the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \" can rest assured that all its resources haven't been destructed yet.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void AtomDispenser::create_all_atom_renderers(Renderer* renderer)\\n{\\n    ...\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"renderer-abstraction\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Renderer Abstraction\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#renderer-abstraction\",\n    \"aria-label\": \"renderer abstraction permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Even though Maki is currently using OpenGL only, different rendering APIs (like Vulcan, Metal or DirectX) can easily be added.\\nTo achieve this many low-lever rendering concepts are implemented using abstract classes (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shader\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Renderer\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"VertexBuffer\"), \").\\nThe actual API specific implementations (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OpenGLShader\"), \") can be found in a subdirectory:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \".\\n\\u251C\\u2500\\u2500 opengl\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.cpp\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.h\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.h\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 ...\\n\\u251C\\u2500\\u2500 buffer.cpp\\n\\u251C\\u2500\\u2500 buffer.h\\n\\u251C\\u2500\\u2500 renderer.cpp\\n\\u251C\\u2500\\u2500 renderer.h\\n\\u251C\\u2500\\u2500 ...\\n\")), mdx(\"p\", null, \"The abstract classes define the static function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"create\"), \" to create an instance of the appropriate class:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"IndexBuffer* IndexBuffer::create(uint32_t count, const uint32_t* indices)\\n{\\n    switch(Renderer::get_renderer_impl()) {\\n\\n    ...\\n\\n    case Renderer::Implementation::opengl:\\n        return new OpenGLIndexBuffer(count, indices);\\n    default:\\n        MAKI_RAISE_CRITICAL(\\\"The requested renderer implementation is not supported.\\\");\\n        return nullptr;\\n    }\\n}\\n\")), mdx(\"p\", null, \"The static function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Renderer::set_renderer_impl\"), \" is used to globally define the renderer API at Maki's boot up.\"), mdx(\"p\", null, \"This decision, which renderer API should be used, is performed at runtime.\\nThat way the user can decide which implementation to use:\\nEven so you're on Windows, you might want to use OpenGL instead of DirectX because you have custom shaders written in GLSL.\"), mdx(\"p\", null, \"The situation is different for the platform, i.e. the window handling mechanism, which is selected based on the type of target system.\\nGLFW can be used on Linux, Windows and the MacOS;\\nWebAssembly might need something else.\\nThe crucial difference to the renderer API is that the decision, which platform is to be used, can be made at compile time.\\nBy using preprocessor statements to only compile the required platform, some runtime overhead can be removed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#if PROJECT == glfw\\n    GLFWwindow* m_handle {nullptr};\\n#endif\\n\")), mdx(\"p\", null, \"This macro can be set using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-Dplatform=glfw\"), \" flag.\"), mdx(\"p\", null, \"As you can see \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"extensibility\"), \" lies at the heart of Maki.\"), mdx(\"h1\", {\n    \"id\": \"multi-threading\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Multi Threading\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#multi-threading\",\n    \"aria-label\": \"multi threading permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"There are always two things happening at the same time:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"accepting new or changes to atoms from Python and\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"rendering the scene or handling user interaction.\")), mdx(\"p\", null, \"It makes sense to use two different threads, a control and a render thread, to tackle this concurrency.\\nSince OpenGL doesn't allow multiple threads to use the same context, only the render thread is allowed to perform render calls.\\nThe control thread on the other hand is the only one Python can directly interface with.\\nTherefore data has to safely be exchanged between the two threads.\\nIn addition to, that each thread should under no circumstances be allowed to perform actions outside of its jurisdiction.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RenderDriver\"), \" owns all threads and contains the entry point for each.\\nWhen Maki wakes up, the first order of business is to initialize the (main) control thread, after which the render thread is to be created.\\nThis initialization includes calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SET_THREAD_TYPE_CONTROL()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SET_THREAD_TYPE_RENDER()\"), \" from the respective thread.\\nThese preprocessor macros define a thread local global variable keeping track of the current thread being used.\"), mdx(\"p\", null, \"Every function can then be equipped with a call to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MAKI_ASSERT_CTRL_THREAD()\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MAKI_ASSERT_RNDR_THREAD()\"), \", which asserts that the correct thread is being used.\\nSince these checks are being removed for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Release\"), \" mode and are only included in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Debug\"), \" builds (which can be specified using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"-DCMAKE_BUILD_TYPE=Release\"), \" flag) there is no runtime overhead.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"#ifndef NDEBUG\\n...\\n#define MAKI_ASSERT_CTRL_THREAD()                              \\\\\\n    MAKI_ASSERT_CRITICAL(g_thread_type == ThreadType::control, \\\\\\n                         \\\"This function can only be called from the control thread.\\\")\\n#define MAKI_ASSERT_RNDR_THREAD()                             \\\\\\n    MAKI_ASSERT_CRITICAL(g_thread_type == ThreadType::render, \\\\\\n                         \\\"This function can only be called from the render thread.\\\")\\n#else\\n...\\n// don't do anything in release mode\\n#define MAKI_ASSERT_CTRL_THREAD()\\n#define MAKI_ASSERT_RNDR_THREAD()\\n\\n#endif\\n\")), mdx(\"p\", null, \"To prevent race conditions, no two threads are accessing the same resource concurrently, mutexes are being used.\\nThese \\\"mutual exclusion objects\\\" allow the locking of a resource for the duration of its use.\\nIn addition to this locking operation being a rather expensive one, all other threads in need of that resource are being stalled.\\nTherefore the use of mutexes should be minimized.\"), mdx(\"p\", null, \"These two precautions, preventing the threads from running wrong functions and accessing resources at the same time, form the basis for Maki's \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"thread safety\"), \".\"), mdx(\"h1\", {\n    \"id\": \"atoms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Atoms\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#atoms\",\n    \"aria-label\": \"atoms permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Just like how real atoms were thought to be the indivisible unit of the universe atoms are the smallest renderable unit in Maki.\\nA collection of them form a frame, multiple of which form an entire scene that can be rendered to a video file.\"), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" stores all the data required to render that atom.\\nThis mainly includes any vertex data, like position or colour.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"struct Atom {\\n    bool render {false};\\n\\n    // to be defined by implementation:\\n    // static constexpr const char* type_name {\\\"Atom\\\"};\\n};\\n\\nstruct QuadrilateralAtom: public Atom {\\n    std::array<vec3, 4> ver_pos {\\n        vec3 {-1.0f, -1.0f, +0.0f},  // bottom left\\n        vec3 {+1.0f, -1.0f, +0.0f},  // bottom right\\n        vec3 {-1.0f, +1.0f, +0.0f},  // top    left\\n        vec3 {+1.0f, +1.0f, +0.0f}}; // top    right\\n    ...\\n    static constexpr const char* type_name {\\\"Quadrilateral\\\"};\\n};\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" flag, set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \", excludes the atom from the being-rendered-club.\"), mdx(\"p\", null, \"Because Maki allows the user to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"jump in time\"), \", it needs to keep track of each and every frame.\\nThe simplest way of implementing this is to store all atoms for each frame.\\nThis results in a multitude of problems:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"This way of storing atoms requires a huge (possibly) two-dimensional array, which can quickly drain all available memory.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When the user changes an atom at any frame, all representations of that atom after this frame have to be changed too.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A wait instruction, which simply leaves the scene as is, would consume as much memory as any other instruction.\\nMore frames always mean more memory being consumed, no matter how much is actually happening in them.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Adding a new atom means adding it to all frames.\")), mdx(\"h2\", {\n    \"id\": \"difference-array\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Difference array\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#difference-array\",\n    \"aria-label\": \"difference array permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"To solve these problems I'm using a difference array.\\nThis difference array can be seen as the numerical derivative of the original array;\\ninstead of storing all atoms for every frame, I'm only storing how the atoms change from frame to frame.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s define how an atom has to be altered to cross a frame-border (from one frame to the next, or back from the next to the current).\\nAnything from moving the atom, applying a linear transformation, changing the color or just changing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"render\"), \" flag.\"), mdx(\"p\", null, \"This functionality is implemented in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions.\\nThese take an atom and apply (or reverse) the changes this \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" represents.\\nTheir \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m_id\"), \" member variable can be used to determine the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" should be used for.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template<typename AtomType>\\nclass ToggleRenderDiff: public AtomDiff<AtomType> {\\npublic:\\n    explicit ToggleRenderDiff(uint32_t id)\\n        : AtomDiff<AtomType> {id} {}\\n\\n    virtual void apply(AtomType& atom) const override\\n    {\\n        atom.render = !atom.render;\\n    }\\n    virtual void reverse(AtomType& atom) const override\\n    {\\n        atom.render = !atom.render;\\n    }\\n};\\n\")), mdx(\"p\", null, \"Templating is used to accept any type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s are always immutable (always declared \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \").\"), mdx(\"p\", null, \"This solves all of the aforementioned problems:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Since \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AtomDiff\"), \"s only contain the data they absolutely need to apply the change they represent, they consume very little memory.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When the user changes an atom at any frame, only an \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AtomDiff\"), \" for that frame has to be created.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"When nothing happens in your scene, no \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AtomDiff\"), \"s are being stored and basically no memory is consumed;\\nyou can wait for as long as you like.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Adding a new atom doesn't change anything about the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AtomDiff\"), \"s.\")), mdx(\"p\", null, \"The actual difference array is implemented in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nAn \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \" contains one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffFrame\"), \" for each frame.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffFrame\"), \"s are a container for all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s belonging to a single frame.\\nThe \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"apply\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reverse\"), \" member functions take an entire list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s as a parameter.\\nThe aforementioned \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m_id\"), \" member variable is used to apply (or reverse) the correct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s on the correct \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void apply(std::vector<AtomType>& atoms) const\\n{\\n    for(const AtomDiff<AtomType>* atom_diff: m_atom_diffs) {\\n        atom_diff->apply(atoms[atom_diff->get_id()]);\\n    }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"atomchain\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"AtomChain\"), mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#atomchain\",\n    \"aria-label\": \"atomchain permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomChain\"), \"s can be seen as pointing to within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nBeing one of the central classes, an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomChain\"), \" contains all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atoms\"), \" of one type in a specific state defined by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \".\\nThis \\\"pointer\\\" can freely be moved around to represent the requested frame.\\nTo achieve this the underlying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s owned by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \" are being used to reach the target frame.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"void set_frame(\\n    uint32_t frame,\\n    const AtomDiffLifetime<AtomType>& atom_diff_lifetime)\\n{\\n    ...\\n\\n    while(m_frame < frame)\\n        // adjust m_frame and call atom_diff_lifetime.apply\\n        next_frame(atom_diff_lifetime);\\n    while(m_frame > frame)\\n        prev_frame(atom_diff_lifetime);\\n}\\n\")), mdx(\"p\", null, \"There are always two atom chains in use for any type, a control and a render atom chain.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The render atom chain is needed to render the frame the interactive window requests.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To apply any absolute changes at frame \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" the control thread needs to know what the last state of frame \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is.\\nOtherwise it wouldn't know how to adjust the atoms in frame \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x-1\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \".\\nThus the control thread needs its own atom chain that can be moved without tampering with the render atom chain.\\nThis is not necessary for relative changes.\")), mdx(\"p\", null, \"The first frame is frame \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \".\\nIt cannot display anything as it is used as the foundation for any following frames.\\nOnly subsequent frames can be the target of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s.\"), mdx(\"h2\", {\n    \"id\": \"chrono-syncs\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Chrono Syncs\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#chrono-syncs\",\n    \"aria-label\": \"chrono syncs permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"One might wonder what happens when the control atom chain changes a frame that lies before the render atom chain.\\nIn this situation the render atom chain would be outdated, because its \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"past\"), \" changed.\\nTo fix this Maki performs a chrono sync.\\nThis means that the render atom chain evicts all of it's data and recreates all atoms.\\nTherefore it points at the 0th frame.\\nSince this frame can't contain any atom diffs, the render thread is synchronised again.\\nTo get back to where the render atom chain left off, it can use the already explained \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"set_frame\"), \" member function.\"), mdx(\"h2\", {\n    \"id\": \"templated-memory\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Templated Memory\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#templated-memory\",\n    \"aria-label\": \"templated memory permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDispenser\"), \" gives birth to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atoms\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffs\"), \" besides owning one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiffLifetime\"), \" and all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomChains\"), \" for each type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nMultiple templated member functions are being used to access the correct ones.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"class AtomDispenser {\\n\\n    ...\\n\\n    template<typename AtomType>\\n    AtomDiffLifetime<AtomType>& get_diff_lifetime();\\n    \\n    ...\\n};\\n\\n// for CuboidAtoms\\ntemplate<>\\ninline AtomDiffLifetime<CuboidAtom>& AtomDispenser::get_diff_lifetime<CuboidAtom>()\\n{\\n    return m_cuboid_diff_lifetime;\\n}\\n// for QuadrilateralAtoms\\ntemplate<>\\ninline AtomDiffLifetime<QuadrilateralAtom>& AtomDispenser::get_diff_lifetime<QuadrilateralAtom>()\\n{\\n    return m_quadrilateral_diff_lifetime;\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"rendering-atoms\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Rendering Atoms\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#rendering-atoms\",\n    \"aria-label\": \"rendering atoms permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomRenderer\"), \" uses the underlying rendering abstraction to actually render an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nThe implementation of such may vary wildly as each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" has a different optimal way of being rendered.\\nWhile some may use a common base class (like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BatchRenderer\"), \") others stand on their own.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomRendererRouter\"), \" is unfortunately needed to make these different implementations accessible from the templated world of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"template<typename AtomType>\\nstruct AtomRendererRouter {\\n    // can't be used unspecialized\\n    typedef void type;\\n};\\n\\ntemplate<>\\nstruct AtomRendererRouter<CuboidAtom> {\\n    typedef CuboidRenderer type;\\n};\\n\\ntemplate<>\\nstruct AtomRendererRouter<QuadrilateralAtom> {\\n    typedef QuadrilateralRenderer type;\\n};\\n\")), mdx(\"p\", null, \"This router can be used like this to resolve \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" types to their respective renderer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"typename AtomRendererRouter<CuboidAtom>::type* m_cuboid_renderer {nullptr};\\n\")), mdx(\"p\", null, \"Being converted to this by the compiler:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cpp\"\n  }, \"CuboidRenderer* m_cuboid_renderer {nullptr};\\n\")), mdx(\"p\", null, \"(The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{nullptr}\"), \" is not necessary but always a nice touch ^^).\"), mdx(\"h2\", {\n    \"id\": \"why-templates\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Why Templates?\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#why-templates\",\n    \"aria-label\": \"why templates permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"Why not use an arguably much simpler object-oriented approach?\"), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \" can be applied to any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" that provides the necessary member functions (an atom that doesn't have a color can't be painted red).\\nSo \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s are templated to suit any such \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nInstead of using templates, I could have used an abstract \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" base class and make the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s be applied to an inheritor of such base class.\"), mdx(\"p\", null, \"The problem with that lays in the way the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s are being accessed.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \"s are currently stored in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \", which is the silly C++ way of saying \\\"dynamic size array\\\".\\nThere is one \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" for each type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nMemory allocated by an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" is always contiguous.\\nTherefore the atoms lay side by side and the renderer, chewing through all atoms one at a time, gets sped up by the hardware prefetcher.\"), mdx(\"p\", null, \"But this only works since the compiler knows the size of that type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \".\\nIf I were to use inheritance and a single \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \", the size of an actual \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Atom\"), \" isn't always the same.\\nFor example a Cube needs a lot more data than a triangle.\"), mdx(\"p\", null, \"This can still be done of course.\\nThe way to do it is by storing pointers to the actual objects.\\nThat means that the objects are scattered all over the memory and the hardware prefetcher feels an urge to give up.\\nIn this case using contiguous memory amounts to a total \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"performance\"), \" increase of 35 to 60 (!!!) percent.\"), mdx(\"p\", null, \"I could have still used multiple \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"std::vector\"), \"s even with inheritance.\\nBut that means that all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AtomDiff\"), \"s and any other objects need to accept abstract types and potentially cast them down into more specific ones.\\nThis adds performance overhead because any one function can't be optimized for one type of atom and dynamic casting isn't exactly free.\\nTo put it in a nutshell, I'm incredibly \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"afraid of loosing type information\"), \".\"), mdx(\"h2\", {\n    \"id\": \"appendix\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Appendix\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#appendix\",\n    \"aria-label\": \"appendix permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"p\", null, \"You can find Maki's current status on GitHub at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/christopher-besch/maki\"\n  }, \"christopher-besch/maki\"), \".\\nMaki's version as of this article's writing can be accessed \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/christopher-besch/maki/tree/0b844480b511a08b81e7f87d50a3b7Fc4e764d85\"\n  }, \"here\"), \".\\nFeel free to leave a star ^^\"), mdx(\"h3\", {\n    \"id\": \"directory-overview\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, \"Directory Overview\", mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#directory-overview\",\n    \"aria-label\": \"directory overview permalink\",\n    \"className\": \"anchor after\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  })))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \".\\n\\u251C\\u2500\\u2500 maki\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 maki.cpp\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u251C\\u2500\\u2500 maki_core\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 include\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 maki.h\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 res\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 shaders\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 cuboid_frag.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 cuboid_vert.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u251C\\u2500\\u2500 simple_fragment.glsl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0     \\u2514\\u2500\\u2500 simple_vertex.glsl\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atoms\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_atom.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 quadrilateral_atom.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 quadrilateral_atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderers\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 batch_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 batch_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 cuboid_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 quadrilateral_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 quadrilateral_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_chain.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff_frame.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_diff_lifetime.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_dispenser.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom_dispenser.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 atom.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 atom_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 core\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 definitions.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 log.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 log.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 thread_safety.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 thread_safety.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 driver\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera_driver.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera_driver.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 interface.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 render_driver_control.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 render_driver.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 render_driver_render.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 platform\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 glfw\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 glfw_window.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 enums.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 event.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 window.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 window.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_buffer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_shader.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_shader.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_stringifier.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_stringifier.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_types.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 opengl_vertex_array.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 opengl_vertex_array.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 buffer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 buffer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 camera.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 renderer.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 shader.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 shader.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 types.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 vertex_array.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 vertex_array.h\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 pch.cpp\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 pch.h\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u251C\\u2500\\u2500 stub\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 src\\n\\u2502\\xA0\\xA0 \\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 main.cpp\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 CMakeLists.txt\\n\\u2514\\u2500\\u2500 CMakeLists.txt\\n\")), mdx(\"p\", null, \"Created with\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"tree --dirsfirst . -I 'vendor|build|pretty_bugs|block.txt|imgui.ini|LICENSE|maki.cpython-310-x86_64-linux-gnu.so|maki_showcase.ipynb|README.md'\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"date":"January 2022","title":"Maki, Atoms and Time Travel","description":" Maki showcases how a program for interactive and programmatic animation development can be implemented.\nTo create animations for technical concepts, one is advised to use graphics software with a programmatic approach. While these provide the required precision, they suffer from an inherent disconnect between input and output. An alternative are WYSIWYG programs, which avoid this detachment with interactivity at the cost of precision.\nMaki combines the best of both worlds. ","banner":"/social_banner/maki_01.png"}}},"pageContext":{"slug":"maki_01"}},
    "staticQueryHashes": ["1751226025"]}